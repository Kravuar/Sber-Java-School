### Задание и Выполнение
#### Задание 1. Ваша задача реализовать класс Task
имеющий один метод get():
```java
public class Task<T> { 
    public Task(Callable<? extends T> callable) { 
        ...
    } 
    public T get() { ... }
}
```
Данный класс в конструкторе принимает
экземпляр `java.util.concurrent.Callable`. Callable похож на Runnuble, но результатом его работы является объект (а не
void). 

Ваша задача реализовать метод get() который возвращает результат работы Callable. Выполнение callable должен
начинать тот поток, который первый вызвал метод get(). 

Если несколько потоков одновременно вызывают этот метод, то
выполнение должно начаться только в одном потоке, а остальные должны ожидать конца выполнения (не нагружая процессор).

Если при вызове get() результат уже просчитан, то он должен вернуться сразу, (даже без задержек на вход в
синхронизированную область). Если при просчете результата произошел Exception, то всем потокам при вызове get(), надо
кидать этот Exception, обернутый в ваш RuntimeException (подходящее название своему ексепшену придумайте сами). Задание
#### Задание 2 Реализовать интерфейс ExecutionManager 
```java
public interface ExecutionManager { 
    Context execute(Runnable callback, Runnable... tasks); 
}
```
Метод execute принимает массив тасков, это задания которые ExecutionManager должен
выполнять параллельно (в вашей реализации пусть будет в своем пуле потоков). После завершения всех тасков должен
выполниться callback (ровно 1 раз). 

Метод execute – это неблокирующий метод, который сразу возвращает объект Context.
Context это интерфейс следующего вида:

```java
public interface Context { 
    int getCompletedTaskCount();
    int getFailedTaskCount();
    int getInterruptedTaskCount();
    void interrupt();
    boolean isFinished(); 
}
```
Метод getCompletedTaskCount() возвращает
количество тасков, которые на текущий момент успешно выполнились.

Метод getFailedTaskCount() возвращает количество
тасков, при выполнении которых произошел Exception. 

Метод interrupt() отменяет выполнения тасков, которые еще не начали
выполняться. 

Метод getInterruptedTaskCount() возвращает количество тасков, которые не были выполены из-за отмены (
вызовом предыдущего метода). 

Метод isFinished() вернет true, если все таски были выполнены или отменены, false в
противном случае.

###### ** Реализация **

#### Задача 1
Был реализован класс `Task` (основанный на `FutureTask`), метод get выполняется следующим образом:
1. если `volatile state` не `NEW` и не `COMPLETING`, значит завершилось выполнение, возвращаем результат/исключение
2. иначе пытаемся начать выполнение, если ещё не начато, иначе сразу возвращаемся и ожидаем выполнения, затем возвращаем результат/исключение

Эксклюзивное выполнение реализованно с помощью CAS записи в переменную `runner`, представляющую поток, выполняющий задачу (первый, который успел)

В методе `run` выполняющий поток устанавливает результат/исключение задачи в переменную `result` и обновляет `volatile state`, обеспечивая, таким образом, `happens before` не только
для `state`, но и для самого результата. Затем поток сигнализирует о выполнении, и все ожидающие возвращают результат.

Тесты прилагаются
#### Задача 2

Класс `Context` содержит в себе атомарные счётчики выполненных, невыполненных и прерванных задач и ссылку на `ExecutorService` с задачами (для возможности прерывания).

Метод `execute` основного класса оборачивает все задачи в `Callable` с доп. логикой увеличения счётчиков контекста
и запускает их в отдельном `ExecutorService`, ожидает их выполнения и вызывает `callback`

Тесты прилагаются