### Задание и Выполнение

1. Как получить ссылку на текущий поток?
    **Thread.currentThread()**
2. Зачем нужно ключевое слово synchronized ? На что его можно вещать(поле, метод,
   класс, конструктор..)?
    **Реализация критической секции, можно ставить на метод, блок кода,
    установление happens-before между всем, что было видно до выхода из секции и всем, что после следующего входа по тому же объекту блокировки.**
3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок?
   - **Метод - intrinsic lock (есть у каждого объекта)**
   - **static метод - тот же intrinsic lock у объекта Class<?>**
   - **блок - монитор объекта, который передадим в качестве аргумента**
4. Зачем нужно ключевое слово volatile ? На что его можно вещать(поле, метод, класс,
   конструктор..)?
    **Можно вешать на поля класса. Установление happens-before между всем, что было видно перед записью в volatile переменную и последующим её чтением.**
5. Что делает метод Object#wait, Object#notify, Object#notifyAll?
    - **wait - переводит поток в состояние ожидания**
    - **notify - пробуждает случайный поток, ожидающий на данном объекте**
    - **notifyAll - пробуждает все потоки, ожидающие на данном объекте**
6. Что за исключение IllegalMonitorStateException?
    **Выбрасывается при использовании методов wait, notify, notifyAll, если текущим потоком не захвачен монитор объекта**
7. Что делает метод Thread#join?
    **Приостанавливает выполнение текущего потока до завершения указанного потока**
8. Что делает метод Thread#interrupt?
    **Указывает потоку, что ему необходимо остановиться (как и когда - решается в коде того потока)**

#### реализовать ThreadPool
```java
public interface ThreadPool {
   void start(); // запускает потоки. Потоки бездействуют, до тех пор пока не появится новое задание в очереди (см. execute)
   void execute(Runnable runnable); // складывает это задание в очередь. Освободившийся поток должен выполнить это задание. Каждое задание должны быть выполнено ровно 1 раз
}
```
   
#### Сделать 2 реализации ThreadPool
1) FixedThreadPool - Количество потоков задается в конструкторе и не меняется.
2) ScalableThreadPool в конструкторе задается минимальное и максимальное(int min, int max) число потоков,
количество запущенных потоков может быть увеличено от минимального к
максимальному, если при добавлении нового задания в очередь нет свободного потока для
исполнения этого задания. При отсутствии задания в очереди, количество потоков опять
должно быть уменьшено до значения min 


###### ** Реализация **
Была реализована упрощённая версия ThreadPoolExecutor из java.util.concurrent.
`ShrimpleThreadPoolExecutor` работает следующим образом:
- поддерживает блокирующую очередь с заданиями
- поддерживает набор потоков работников в диапазоне от (min, max). Если min=max, то фиксированное кол-во
- потоки-работники (в размере min) создаются лениво
- при получении очередной задачи:
  - проверяется, набрано ли уже min кол-во потоков-работников
    - если нет, то задача кладётся сразу в работника
    - если да, то задача кладётся в очередь
      - если получилось положить в очередь, то задача будет ожидать своего выполнения
      - если нет (скорее всего, закончилось место в очереди), задача минуя очередь кладётся в нового non-core (когда min уже набрано) работника
        - если не получилось создать и нового работника (скорее всего, их уже max), то бросаем `RejectedExecutionException`.
- потоки-работники ожидают (до keepAlive timout`а, затем удаляются, если это не non-core) новой задачи в очереди, выполняя их, пока они есть
- потоки-работники начинают работать после вызова .start() метода (с помощью CountDownLatch)
- некоторые детали были добавлены в комментариях в коде

Тесты прилагаются
