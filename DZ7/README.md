### Задание и Выполнение

#### 1. Ваша задача написать загрузчик плагинов в вашу систему.
Допустим вы пишите свой игра и хотите чтобы люди имели имели возможность писать плагины для неё. Соответственно, разные
разработчики могут назвать свои классы одинаковым именем, ваш загрузчик должен корректно
это обрабатывать. Задача реализовать следующий класс.

```java 
package ru.sbt;

public class PluginManager {
    private final String pluginRootDirectory;

    public PluginManager(String pluginRootDirectory) {
        this.pluginRootDirectory = pluginRootDirectory;
    }

    public Plugin load(String pluginName, String pluginClassName) {
        //todo
    }
}
```

Plugin - это базовый интерфейс для всех плагинов
```java
public interface Plugin {
    //methods doesn't matter
    void doUsefull();
}
```
`PluginManager` ищет скомпилированные классы плагина в папке `pluginRootDirectory\pluginName\`

**Усложненная версия задания.**
Система должна вести себя корректно если в плагине, есть скомпилированные классы с именем, которые есть в вашем браузере(не в плагинах), должны использоваться классы плагина, а не вашего браузера.
Для этого придется поменять модель делегирования класслоадера в методе `loadClass`.

###### **Выполнение в модуле plugin-manager**
Данный модуль содержит следующие классы:
* `ReversedURLClassloader` - загрузчик классов с изменённым порядком делегирования по иерархии загрузчиков
  (сначала сами пытаемся, если нет - делегируем `parent`).
* `PluginManager` - менеджер планигов (загрузчик). Позволяет изолированно загружать плагины с указанным `Class<?> pluginIntefrace`.
  за счёт создания нового `classloader` для каждого (нет коллизий классов), указания `parent` загрузчика (ограничение видимых классов), использования `ReversedURLClassloader` (использование собственных зависимостей).
* `PluginIterator` - итератор загрузчика плагинов, позволяет итерироваться по указанной директории с плагинами, динамически (и лениво) загружая их. (Используется в модуле **arena**)

Также для загрузчика плагинов были написаны тесты.

#### 2. Написать EncryptedClassloader
Данный класслоадер умеет загружать классы из файлов дешифрую их. Ваша задача переопределить метод `findClass()`.
В нем лоадер считывает зашифрованный массив байт, дешифрует его и превращает в класс (с помощью метода `defineClass`).
На вход класслодер принимает ключ шифрования, рутовую папку, в которой будет искать классы, родительский класслодер.
Логика шифрования/дешифрования с использованием ключа может быть любой на ваш вкус (например, каждый считаный байт класса увеличить на определение число).

```java
public class EncryptedClassLoader extends ClassLoader {
    private final String key;
    private final File dir;

    public EncryptedClassLoader(String key, File dir, ClassLoader parent) {
        super(parent);
        this.key = key;
        this.dir = dir;
    }
}
```

###### **Выполнение в модуле decoding-classloader**

В данном модуле определён простой класс, принимающий ключ дешифровки, путь к директории с классами,
и загружающий зашифрованные классы используя прибавляя к каждому байту по `delta=key.length()`.
Тесты прилагаются.

##### 3. Написать игру камень-ножницы-бумага, где в роли игроков будут выступать плагины (файлы с расширением jar).
Будет папка с плагинами, куда будет смотреть приложение.
Каждый плагин должен иметь своё название (по названию файла или по внутреннему состоянию кода).

Плагины будут загружаться по очереди и три раза играть в камень-ножницы-бумагa.
Плагин-победитель остаётся в памяти, а проигравший выгружается.
На место проигравшего загружается следующий плагин из папки и снова происходит игра.
Данные действия повторяются, пока мы не определим плагин-победитель (его название «имя» будет написано в кансоли).
Также по сообщениям из консоли мы должны осозновать, что происходит в процессе отбора победителя.
Предположительно плагин-игрок должен содержать в себе реализацию интерфейса, пример:

```java
Interface PlayableRockPaperScissors {
    RockPaperScissorsEnum play();
}
```

###### **Выполнение в модулях arena, plugin-api и plugins **
Модуль plugin-api содержит простой интерфейс плагинов камень-ножницы-бумага.
Модуль plugins содержит некоторые реализации интерфейса плагинов.
Модуль arena содержит логику сражения плагинов.


Модуль арена также использует `PluginManager` для изолированной загрузки плагинов.
Для этого в Main создаются 2 новых загрузчика классов - один с зависимостями и для приложения и для плагинов,
второй с зависимостями только приложения (имеет первый в качестве `parent`, получая доступ к общим зависимостям).
Оттуда запускается `ArenaRunner` запускающий сражения с указанной директорией плагинов, а также кол-вом раундом для победы в 1 сражении.

Все зависимости распределяются в собранном JAR модуля `arena` на common и core (общие и только для приложения) с помощью плагинов:
* maven-dependency-plugin - копирует зависимости в target
* maven-jar-plugin - собирает jar
* maven-assembly-plugin - кладёт зависимости в jar (деля на common и core)

Для запуска достаточно собрать весь модули plugin-api, plugins, arena, plugin-manager с помощью maven package.
И запустить собранный JAR модуля `arena`: java -jar path-to-arena.jar.
На консоль будет выведено простой консольный интерфейс (начать сражения, выйти).
При запуске сражений нужно указать директорию с плагинами и кол-во раундом для победы в сражении, затем выведутся результаты сражений.