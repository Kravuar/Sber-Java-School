### Задание и Выполнение

#### Реализовать класс похожий на java.util.stream.Stream
Использование этого класса должно выглядеть примерно так:
```java
    List<Person> someCollection = ...
    Map m = Streams.of(someCollection)
        .filter(p -> p.getAge() > 20)
        .transform( p -> new Person(p.geAge() + 30)))
        .toMap(p -> p.geName(), p -> p);
```

`Streams.of()` - статический метод, который принимает коллекцию и создает новый объект Streams
`filter()` - оставляет в коллекции только те элементы, которые удовлетворяют условию в лямбде.
`transform()` - преобразует элемент в другой.
`toMap(...)` - принимает 2 лямбды для создания мапы, в одной указывается, что использовать в качестве
ключа, в другой, что в качестве значения.

После выполнения всех операций коллекция `someCollection` не должна поменяться.
Класс надо параметризовать используя правило PECS

```java
    public class Streams<T> {
    
    public static Streams of(List list) {
        ...
    }
    public Streams filter(...) {
        ...
    }
    public Streams transform(...) {
        ...
    }
    public Map toMap(...) {
        ...
    }
}
```

###### ** Реализация **
Была реализованно сильно упрощённая версия оригинальной Stream API.
Использовались рекурсивные структуры данных:
* `AbstractPipeline` - содержит ссылки на предыдущую (если не начальная) 
и следующую (если есть) стадию pipeline. Стадии операторы так же, как и в Stream API делятся на
terminal и intermediate. Вычисление результата происходит при применении терминального оператора,
при этом вызывается метод `wrapConsumerAndConsume`, происходит подъём по всем стадиям к начальной,
оборачиваются `Consumer` терминального оператора (подъём - в методе `wrapConsumer`,
который вызывает `opWrapConsumer` - обёртка с логикой стадии). Затем каждый элемент
исходного источника передаётся в полностью обёрнутый `Consumer`. Дальнейшая логика зависит от терминального оператора.
* `ChainedConsumer` - непосредственно содержит логику (и `downstream` `Consumer`), которую можно применить перед передачей в `downstream`.

Основные методы `Stream` объявлены в интерфейсе `BadStream` и реализованы в `RefPipeline`. 

Тесты прилагаются.